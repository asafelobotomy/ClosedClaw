/**
 * Shadow Factory — Autonomous Tool Development System
 *
 * Implements the scaffolding for Shadow Factory described in the
 * autonomous-evolution research document.
 *
 * Workflow:
 *   Step A: Dependency Analysis — scan local environment for interaction gaps
 *   Step B: Drafting Subagent — generate .claws file in an air-gapped sandbox
 *   Step C: Recursive Optimization — monitor telemetry, auto-rewrite on poor vibe
 *
 * This module provides the workflow primitives. Actual WASM compilation,
 * sandboxing, and RLHF loops are system-level concerns wired externally.
 */

import type { ClawsPermission, ClawsVerificationProof } from "./claws-parser.js";
import { createClawsTemplate } from "./claws-parser.js";

// ═══════════════════════════════════════════════════════════════════════════
// TYPES
// ═══════════════════════════════════════════════════════════════════════════

/** Lifecycle phase of a shadow tool */
export type ShadowPhase =
  | "reconnaissance"
  | "drafting"
  | "sandbox_testing"
  | "verification"
  | "deployment"
  | "monitoring"
  | "optimization"
  | "failed";

/** An interaction gap discovered during reconnaissance */
export interface InteractionGap {
  /** Descriptive name of the gap */
  name: string;
  /** What the user is trying to do */
  intent: string;
  /** Data sources / APIs involved */
  dataSources: string[];
  /** Why no existing tool covers this */
  reason: string;
  /** Estimated complexity: simple | moderate | complex */
  complexity: "simple" | "moderate" | "complex";
}

/** Result of dependency analysis (Step A) */
export interface ReconnaissanceResult {
  /** Discovered interaction gaps */
  gaps: InteractionGap[];
  /** Local environment details found */
  environment: {
    /** CLI tools available */
    cliTools: string[];
    /** APIs accessible */
    apis: string[];
    /** Local databases found */
    databases: string[];
    /** Git repositories found */
    repositories: string[];
  };
  /** Timestamp of the scan */
  scannedAt: number;
}

/** A draft .claws tool generated by the drafting subagent (Step B) */
export interface ShadowDraft {
  /** Draft ID */
  id: string;
  /** Generated .claws file content */
  clawsContent: string;
  /** Fuzz test statistics */
  fuzzStats: {
    totalRuns: number;
    passed: number;
    failed: number;
    edgeCasesFound: string[];
  };
  /** Whether the draft passed fuzz testing */
  fuzzPassed: boolean;
  /** Timestamp of generation */
  generatedAt: number;
}

/** Sandbox test result (Step B follow-up) */
export interface SandboxTestResult {
  /** Whether all sandbox tests passed */
  passed: boolean;
  /** Number of tests run */
  testCount: number;
  /** Failures (if any) */
  failures: Array<{
    testName: string;
    error: string;
  }>;
  /** Mock API interactions logged */
  apiInteractions: Array<{
    method: string;
    url: string;
    statusCode: number;
  }>;
}

/** Telemetry snapshot for optimization decision (Step C) */
export interface OptimizationSignal {
  /** Current success rate (from telemetry block) */
  successRate: number;
  /** User correction frequency (higher = worse fit) */
  correctionRate: number;
  /** Average latency ms */
  avgLatencyMs: number;
  /** Whether an auto-rewrite is recommended */
  rewriteRecommended: boolean;
  /** Reason for the recommendation */
  reason: string;
}

/** Full lifecycle state of a shadow tool */
export interface ShadowToolState {
  /** Unique tool ID */
  toolId: string;
  /** Current lifecycle phase */
  phase: ShadowPhase;
  /** Reconnaissance data (if completed) */
  reconnaissance: ReconnaissanceResult | null;
  /** Draft data (if generated) */
  draft: ShadowDraft | null;
  /** Sandbox test result (if run) */
  sandboxResult: SandboxTestResult | null;
  /** Verification proof (if verified) */
  verification: ClawsVerificationProof | null;
  /** History of phase transitions */
  phaseHistory: Array<{
    from: ShadowPhase;
    to: ShadowPhase;
    timestamp: number;
    reason: string;
  }>;
  /** Created timestamp */
  createdAt: number;
}

// ═══════════════════════════════════════════════════════════════════════════
// STEP A — DEPENDENCY ANALYSIS
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Analyze a user request and identify interaction gaps.
 *
 * In a full implementation this would scan the local environment, private repos,
 * etc.  This scaffolding accepts pre-discovered data and structures it.
 *
 * @param request - Natural language description of what the user needs
 * @param existingTools - Names of tools already available
 * @param environment - Discovered environment info
 */
export function analyzeGaps(
  request: string,
  existingTools: string[],
  environment: ReconnaissanceResult["environment"],
): ReconnaissanceResult {
  // Check for simple keyword matching against existing tools
  const lowerRequest = request.toLowerCase();
  const coveredTools = existingTools.filter((t) =>
    lowerRequest.includes(t.toLowerCase().replace(/_/g, " ")),
  );

  const gaps: InteractionGap[] = [];

  // If no existing tool matches, it's a gap
  if (coveredTools.length === 0) {
    gaps.push({
      name: `auto_${sanitizeId(request)}`,
      intent: request,
      dataSources: [...environment.apis, ...environment.databases],
      reason: "No existing tool matches this request",
      complexity: estimateComplexity(request, environment),
    });
  }

  return {
    gaps,
    environment,
    scannedAt: Date.now(),
  };
}

// ═══════════════════════════════════════════════════════════════════════════
// STEP B — DRAFTING SUBAGENT
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Generate a draft .claws file for an interaction gap.
 *
 * This produces the initial template. A real implementation would invoke
 * a Shadow Clone (air-gapped drafting subagent) for full generation + fuzz testing.
 *
 * @param gap - The interaction gap to fill
 * @param permissions - Permissions the tool should request
 */
export function generateDraft(
  gap: InteractionGap,
  permissions: ClawsPermission[] = [],
): ShadowDraft {
  const id = `shadow_${gap.name}_${Date.now()}`;

  const clawsContent = createClawsTemplate({
    id: gap.name,
    version: "0.1.0",
    purpose: gap.intent,
    trigger: `When the user wants to ${gap.intent.toLowerCase()}`,
    permissions,
  });

  return {
    id,
    clawsContent,
    fuzzStats: {
      totalRuns: 0,
      passed: 0,
      failed: 0,
      edgeCasesFound: [],
    },
    fuzzPassed: false,
    generatedAt: Date.now(),
  };
}

/**
 * Record fuzz test results on a draft.
 */
export function recordFuzzResults(
  draft: ShadowDraft,
  totalRuns: number,
  passed: number,
  edgeCases: string[] = [],
): ShadowDraft {
  return {
    ...draft,
    fuzzStats: {
      totalRuns,
      passed,
      failed: totalRuns - passed,
      edgeCasesFound: edgeCases,
    },
    fuzzPassed: passed === totalRuns && totalRuns > 0,
  };
}

// ═══════════════════════════════════════════════════════════════════════════
// STEP C — OPTIMIZATION
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Evaluate telemetry and decide whether an optimization rewrite is needed.
 *
 * Thresholds:
 *   - Success rate < 0.85 → rewrite recommended
 *   - Correction rate > 0.3 → rewrite recommended (poor vibe)
 *   - Avg latency > 5000ms → rewrite recommended (performance)
 */
export function evaluateOptimization(
  successRate: number,
  correctionRate: number,
  avgLatencyMs: number,
): OptimizationSignal {
  const reasons: string[] = [];

  if (successRate < 0.85) {
    reasons.push(`Low success rate (${(successRate * 100).toFixed(1)}%)`);
  }
  if (correctionRate > 0.3) {
    reasons.push(`High correction rate (${(correctionRate * 100).toFixed(1)}%) — poor vibe`);
  }
  if (avgLatencyMs > 5000) {
    reasons.push(`High latency (${Math.round(avgLatencyMs)}ms)`);
  }

  return {
    successRate,
    correctionRate,
    avgLatencyMs,
    rewriteRecommended: reasons.length > 0,
    reason: reasons.length > 0 ? reasons.join("; ") : "Metrics within acceptable range",
  };
}

// ═══════════════════════════════════════════════════════════════════════════
// LIFECYCLE MANAGEMENT
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Create a new shadow tool lifecycle state.
 */
export function createShadowTool(toolId: string): ShadowToolState {
  return {
    toolId,
    phase: "reconnaissance",
    reconnaissance: null,
    draft: null,
    sandboxResult: null,
    verification: null,
    phaseHistory: [],
    createdAt: Date.now(),
  };
}

/**
 * Advance a shadow tool to the next phase.
 * Validates phase transitions (no skipping).
 */
export function advancePhase(
  tool: ShadowToolState,
  nextPhase: ShadowPhase,
  reason: string,
): ShadowToolState {
  const VALID_TRANSITIONS: Record<ShadowPhase, ShadowPhase[]> = {
    reconnaissance: ["drafting", "failed"],
    drafting: ["sandbox_testing", "failed"],
    sandbox_testing: ["verification", "drafting", "failed"],
    verification: ["deployment", "drafting", "failed"],
    deployment: ["monitoring", "failed"],
    monitoring: ["optimization", "failed"],
    optimization: ["drafting", "deployment", "failed"],
    failed: ["reconnaissance"],
  };

  const allowed = VALID_TRANSITIONS[tool.phase] ?? [];
  if (!allowed.includes(nextPhase)) {
    throw new Error(
      `Invalid phase transition: ${tool.phase} → ${nextPhase} (allowed: ${allowed.join(", ")})`,
    );
  }

  return {
    ...tool,
    phase: nextPhase,
    phaseHistory: [
      ...tool.phaseHistory,
      { from: tool.phase, to: nextPhase, timestamp: Date.now(), reason },
    ],
  };
}

// ═══════════════════════════════════════════════════════════════════════════
// HELPERS
// ═══════════════════════════════════════════════════════════════════════════

function sanitizeId(input: string): string {
  return input
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "_")
    .replace(/^_|_$/g, "")
    .slice(0, 40);
}

function estimateComplexity(
  request: string,
  env: ReconnaissanceResult["environment"],
): "simple" | "moderate" | "complex" {
  const words = request.split(/\s+/).length;
  const dataSources = env.apis.length + env.databases.length;

  if (words <= 10 && dataSources <= 1) {
    return "simple";
  }
  if (words <= 25 && dataSources <= 3) {
    return "moderate";
  }
  return "complex";
}
